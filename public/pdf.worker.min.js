/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

"use strict";
var pdfjsLib;
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/pdf.worker.js
  var pdf_worker_exports = {};
  __export(pdf_worker_exports, {
    WorkerMessageHandler: () => WorkerMessageHandler
  });

  // src/core/worker.js
  var WorkerTask = class {
    constructor(name) {
      this.name = name;
      this.callback = null;
      this.isReady = false;
      this._tryReady();
    }
    setCallback(callback) {
      this.callback = callback;
      this._tryReady();
    }
    _tryReady() {
      if (!this.callback || this.isReady) {
        return;
      }
      Promise.resolve().then(() => {
        this.isReady = true;
      });
    }
  };
  var WorkerMessageHandler = class {
    constructor() {
      this._worker = globalThis;
      this._ready = false;
      this._port = null;
      this._setupFakeWorker();
    }
    _setupFakeWorker() {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
        return;
      }
      if (this._worker.pdfjsWorker) {
        if (!this._worker.pdfjsWorker.WorkerMessageHandler) {
          throw new Error("The fake worker is not compatible with the current PDF.js build.");
        }
        return;
      }
      this._worker.pdfjsWorker = {
        WorkerMessageHandler: this.constructor,
        WorkerTask,
        setupFakeWorker: () => {
          this._setupFakeWorker();
        }
      };
    }
    async _initializeFromPort(port) {
      this._port = port;
      this._port.onmessage = this.onmessage.bind(this);
      this._ready = new Promise((resolve, reject) => {
        this._port.postMessage({
          source: "worker",
          action: "ready"
        });
        const onReady = (event) => {
          if (event.data?.source !== "main" || event.data?.action !== "ready") {
            return;
          }
          this._port.removeEventListener("message", onReady);
          globalThis.removeEventListener("message", onReady);
          try {
            this._loadBuiltinCMap(event.data.data);
            resolve();
          } catch (ex) {
            reject(ex);
          }
        };
        this._port.addEventListener("message", onReady);
        globalThis.addEventListener("message", onReady);
        setTimeout(() => {
          reject(new Error("Worker timed out waiting for the main thread."));
        }, 1e4);
      });
    }
    _loadBuiltinCMap(data) {
      if (!data) {
        return;
      }
      const { cMapUrl, cMapPacked } = data;
      if (cMapUrl && cMapPacked) {
        pdfjsLib.CMapReaderFactory.initialize({
          cMapUrl,
          cMapPacked
        });
      }
    }
    onmessage(event) {
      const data = event.data;
      if (data?.source === "main") {
        if (data.action === "initialize") {
          this._initializeFromPort(event.ports[0]);
          return;
        }
        if (data.action === "main-exit") {
          if (this._port) {
            this._port.close();
          }
          return;
        }
      }
      this._ready.then(() => {
        const { source, action } = data;
        if (source !== "main") {
          return;
        }
        switch (action) {
          case "configure":
            this.setup(data.data);
            break;
          case "abort":
            this.abort(data.data);
            break;
          default:
            this.callback(data);
            break;
        }
      });
    }
    setCallback(callback) {
      this.callback = callback;
    }
    setup(data) {
      this.callback(data);
    }
    abort(data) {
      this.callback(data);
    }
    send(data, transfers) {
      if (this._port) {
        this._port.postMessage({
          source: "worker",
          action: "response",
          data
        }, transfers);
      }
    }
  };

  // src/pdf.worker.js
  if (typeof pdfjsLib === "undefined") {
    globalThis.pdfjsLib = {};
  }
  if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("SKIP_WORKER_BUNDLE")) {
    (function() {
      const workerSrc = "pdf.worker.js";
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
        globalThis.pdfjsLib.workerSrc = workerSrc;
        return;
      }
      if (typeof document === "undefined") {
        globalThis.pdfjsLib.workerSrc = workerSrc;
        return;
      }
      globalThis.pdfjsLib.workerSrc = document.currentScript?.src || workerSrc;
    })();
  }
  module.exports = __toCommonJS(pdf_worker_exports);
})();